/* ******************************************************
*  File Name: BatteryWeight.int                         *
*  Date: September 20, 2012                             *
*  Created by: Andrew Urcinas                           *
*  Last Edited: October 23, 2012                        *
*  By: Andrew Urcinas                                   *
*  For: Aerospace Systems Design Lab @ Georgia Tech     *
*******************************************************	*/

/* ******************************************************
*  Functions:                                           *
*	BatteryWeight    class                                *
*******************************************************	*/


// ==============================================================================
// BatterySizer (class)
// Allows sizing of battery base	d on design power load and necessary capacity
// ------------------------------------------------------------------------------

extern int Ncells;
extern real Capacity;
extern real k_2;
extern real StackWeight;
extern real StackVol;

class BatteryWeight extends Subelement {

	real SpecEnergy {
		value = 1; IOstatus = INPUT; //units = Wh/kg;
		description = "Energy capacity per unit weight of the battery";
	}
	real PowerDensity {
		value = 1; IOstatus = INPUT; //units = "W/m3";
		description = "Energy capacity per unit weight of the battery";
	}
	
	real SpecPower {
		value = 1; IOstatus = INPUT; //units = "W/m3";
		description = "Battery specific power";
	}
	
	real PowerBattNom {
		value = 1; IOstatus = INPUT; //units = "W";
		description = "Nominal Power output of battery";
	}
	real VoltageNominal {
		value = 1; IOstatus = INPUT; //units = "V";
		description = "Nominal voltage of battery";
	}

	// SOCKETS
	addInterface("BATTERY_WEIGHT");

	void calculate () {

	  //----------------------------------------------------------------
	  // create locals for variables returned to parent
	  //----------------------------------------------------------------
		
		//Initial Guess
		real SpecificEnergy = 100.; 
		
		real PowerDensityR = calc_power_density(SpecificEnergy);
		real thetaR = atan(PowerDensityR/SpecificEnergy);
		
		//Tolerance Allowed
		real accuracy = 0.0001;
		
		//Actual Point on Ragone Curve
		real Power = DesPower * PqPdes_Max ; //cout << "DesPower = " << DesPower << endl;
		real Energy = Capacity * VoltageNominal * Ncells ;
		real theta = atan(C_Max); 
		real StackWeight_ret;
		int counter = 0;
		while(abs(theta - thetaR)>accuracy) {
			SpecificEnergy = min((SpecificEnergy*(1 + .1*((thetaR- theta)/theta))),175.);
			// cout << "(thetaR- theta)/theta = " << (thetaR- theta)/theta << endl;
			PowerDensityR = calc_power_density(SpecificEnergy);
			thetaR = atan(PowerDensityR/SpecificEnergy); 
			if(SpecificEnergy == 175. && theta <= thetaR) {
				break;
			}
			counter++;
			if(counter > 500) {
				break;
			}
		}
		
		SpecPower = PowerDensityR;
		SpecEnergy = SpecificEnergy;
		
		real StackVol_ret; 
			
		SpecificEnergy = Specific_Energy;
		
		StackWeight_ret = Energy /SpecificEnergy;
		StackVol_ret = Ncells*PowerBattNom/PowerDensity;

		StackWeight = StackWeight_ret;
		StackVol = StackVol_ret;
	}
	
	real calc_power_density(real SpecificEnergy) {
		
		real SpecificEnergy1 = 175.; //upper bound -- far right
		real SpecificEnergy2 = 128.79; 
		real SpecificEnergy3 = 93.28;
		real SpecificEnergy4 = 61.94;
		real SpecificEnergy5 = 41.24;
		real SpecificEnergy6 = 11.37; //lower bound -- far left
		
		real PowerDensity_ret;
		if(SpecificEnergy < SpecificEnergy1 && SpecificEnergy >= SpecificEnergy2) {
			PowerDensity_ret = (0.053*SpecificEnergy**2) - (21.14*SpecificEnergy) + 2084.1;
		} else if(SpecificEnergy <= SpecificEnergy2 && SpecificEnergy >= SpecificEnergy3) {
			PowerDensity_ret = (0.1942*SpecificEnergy**2) - (69.348*SpecificEnergy) + 5975.6;
		} else if(SpecificEnergy <= SpecificEnergy3 && SpecificEnergy >= SpecificEnergy4) {
			PowerDensity_ret = (0.3887*SpecificEnergy**2) - (132.23*SpecificEnergy) + 10197;

		} else if(SpecificEnergy <= SpecificEnergy4 && SpecificEnergy >= SpecificEnergy5) {
			PowerDensity_ret = (-0.3048*SpecificEnergy**2) - (96.666*SpecificEnergy) + 10441;

		} else if(SpecificEnergy <= SpecificEnergy5 && SpecificEnergy >= SpecificEnergy6) {
			PowerDensity_ret = (-2.5546*SpecificEnergy**2) - (174.67*SpecificEnergy) + 17510 ;

		} else if (SpecificEnergy >= SpecificEnergy1) {
			SpecificEnergy = SpecificEnergy1;
			PowerDensity_ret = (0.053*SpecificEnergy**2) - (21.14*SpecificEnergy) + 2084.1;//equation 1
		
		} else if (SpecificEnergy < SpecificEnergy6) {
			SpecificEnergy = SpecificEnergy6;
			PowerDensity_ret = (-2.5546*SpecificEnergy**2) - (174.67*SpecificEnergy) + 17510; //equation 5
		}
		
		return PowerDensity_ret;
		
	}
}