//
//------------------------------------------------------------------------
//                                                                       |
//   File Name:     SFTF.mdl                                             |
//   Date(s):       March 24, 2008                                       |
//   Author:        Russ Denney and Jimmy Tai                            |
//                                                                       |
//   Description:   Mixed Flow Turbofan engine model                     |
//                                                                       |
//------------------------------------------------------------------------
//------------------------------------------------------------------------

setThermoPackage("GasTbl");

//----------------------------------------------------------------------------
//                           User-Defined Elements
//----------------------------------------------------------------------------

#include <MFTF.fnc>
#include <Efficiencies.fnc>
#include <TCLA.fnc>
#include <Supersonic_Inlet.int>
#include <Supersonic_Inlet_sub3.int>
#include <Emission.int>; 
#include <Weight_Calculations_SFTF.int>
#include "Nozzle.int"
//----------------------------------------------------------------------------
//                           Shaft Element Extension
//----------------------------------------------------------------------------

class Shaft1 extends Shaft{
   real Ndes=0;
   real NqNdes=0;
   real NqNdesPct=0;
   //variableChanged logic
   void variableChanged( string name, any oldVal ) {
      Shaft::variableChanged( name, oldVal );
      if (name=="switchDes"){
         if (switchDes=="DESIGN"){
            Ndes=Nmech;
            NqNdes=1.0;
            NqNdesPct=NqNdes*100;
         }
      }
   }
   //Engineering Calculations
   void calculate() {
      Shaft::calculate();
      NqNdes=Nmech/Ndes;
      NqNdesPct=NqNdes*100;
   }
}//ends Shaft1

//----------------------------------------------------------------------------
//                           Duct Element Extension
//----------------------------------------------------------------------------

class Duct1 extends Duct{
   real dPqQ=0;
   //Engineering Calculations
   void calculate() {
      Duct::calculate();
      dPqQ=(Fl_I.Pt-Fl_O.Pt)/(Fl_I.Pt-Fl_I.Ps);
   }
}//ends Duct1

//----------------------------------------------------------------------------
//                           Burner Element Extension
//----------------------------------------------------------------------------

class Burner1 extends Burner{
   real dPqQ=0;
   //Engineering Calculations
   void calculate() {
      Burner::calculate();
      dPqQ=(Fl_I.Pt-Fl_O.Pt)/(Fl_I.Pt-Fl_I.Ps);
   }
}//ends Burner1

//----------------------------------------------------------------------------
//              Socket for Nozzle Dishcarge Coefficient 
//----------------------------------------------------------------------------
// Note Table DischargeCoeff is defined in the parent element

class CDTH extends Subelement {

  real PR_local {
	 value = 0.0 ;
	 IOstatus = "input" ;
	 description = "Nozzle pressure ratio" ;
	 units = "NONE"; 
  }
 
 void calculate() {	
          PR_local = PR;   // PR calculated in parent element nozzle
	    CdTh = DischargeCoeff (PR_local) ;
  } 
} // end CDTH


//----------------------------------------------------------------------------
//              Socket for Nozzle Gross Thrust Coefficient 
//----------------------------------------------------------------------------
// Note Table ThrustCoeff is defined in the parent element

class CFGR extends Subelement {

  real PR_local {
	 value = 0.0 ;
	 IOstatus = "input" ;
	 description = "Nozzle pressure ratio" ;
	 units = "NONE"; 
  }
 
  real CfgDelta {
	  value = 0.0;
	  description = "Delta for Mixer-ejector calcs";
  }
 
 void calculate() {	
        PR_local = PR;   // PR calculated in parent element nozzle
		Cfg = ThrustCoeff (PR_local) - CfgDelta * ThrustCoeff (PR_local);
  } 
} // end CFGR

//----------------------------------------------------------------------------
//              Socket for Compressor Reynolds Number Effects
//----------------------------------------------------------------------------
// Note tables are defined in the map file

class COMPRESSOR_REYNOLDS_EFFECTS extends Subelement {

  real PtRef {
	 value = 14.696;
	 IOstatus = "input" ;
	 description = "Reference pressure for Reynolds number index" ;
	 units = "NONE"; 
  }

  real TtRef {
	 value = 518.67;
	 IOstatus = "input" ;
	 description = "Reference temperature for Reynolds number index" ;
	 units = "NONE"; 
  }

  real RNI_local {
	 value = 0.0 ;
	 IOstatus = "input" ;
	 description = "Reynolds number index" ;
	 units = "NONE"; 
  }

  real PR_local {
	 value = 0.0 ;
	 IOstatus = "input" ;
	 description = "Map pressure ratio" ;
	 units = "NONE"; 
  }

  real gamExp {
	 value = 0.0 ;
	 IOstatus = "input" ;
	 description = "gamma exponent" ;
	 units = "NONE"; 
  }

  real d_effRe {
	 value = 0.0 ;
	 IOstatus = "output" ;
	 description = "adder on compressor POLYTROPIC efficiency for Reynolds number effects" ;
	 units = "NONE"; 
  }
 
 void calculate() {
    PR_local = PRmap;	
    gamExp = (Fl_I.gamt-1.)/Fl_I.gamt;

    s_WcRe = 1.00;
    s_effRe = 1.00;
    s_PrRe = 1.00;
           RNI_local = ( ( Fl_I.Tt + 198.72 ) * (Fl_I.Pt/PtRef) ) / ( ( TtRef + 198.72 ) * (Fl_I.Tt/TtRef) * (Fl_I.Tt/TtRef) ) ;
           d_effRe = d_etaPolyRe(RNI_local);
           s_effRe = (effMapPoly + d_effRe)/effMapPoly;   // convert delta to scalar on POLYTROPIC efficiency
           s_effRe = (PR_local**gamExp-1.)/(PR_local**(gamExp/s_effRe)-1.);  // convert scalar on POLYTROPIC to scalar on ADIABATIC
           s_WcRe = s_FlowRe(RNI_local);
           s_PrRe = s_PressRe(RNI_local);
  } 
} // end COMPRESSOR_REYNOLDS_EFFECTS 

//----------------------------------------------------------------------------
//              Socket for Turbine Reynolds Number Effects
//----------------------------------------------------------------------------
// Note tables are defined in the map file

class TURBINE_REYNOLDS_EFFECTS extends Subelement {

  real PtRef {
	 value = 14.696; // 413.27;  // value set by SLS design point
	 IOstatus = "input" ;
	 description = "Reference pressure for Reynolds number index" ;
	 units = "NONE"; 
  }

  real TtRef {
	 value = 518.67; // 3294.8;  // value set by SLS design point
	 IOstatus = "input" ;
	 description = "Reference temperature for Reynolds number index" ;
	 units = "NONE"; 
  }
  real RNI_local {
	 value = 0.0 ;
	 IOstatus = "input" ;
	 description = "Reynolds number index" ;
	 units = "NONE"; 
  }

  real d_effRe {
	 value = 0.0 ;
	 IOstatus = "output" ;
	 description = "adder on turbine ADIABATIC efficiency for Reynolds number effects" ;
	 units = "NONE"; 
  }
 
 void calculate() {
    s_WpRe = 1.00;
    s_effRe = 1.00;
    s_PrRe = 1.00;
    PtRef = parent.PREF_DES;
    TtRef = parent.TREF_DES;
           RNI_local = ( ( Fl_I.Tt + 198.72 ) * (Fl_I.Pt/PtRef) ) / ( ( TtRef + 198.72 ) * (Fl_I.Tt/TtRef) * (Fl_I.Tt/TtRef) ) ;
           d_effRe = d_etaAdiaRe(RNI_local);
           s_effRe = (effMap + d_effRe)/effMap;   // convert delta to scalar on ADIABATIC efficiency
           s_WpRe = s_FlowRe(RNI_local);
  } 
} // end TURBINE_REYNOLDS_EFFECTS 

//----------------------------------------------------------------------------
//                            Model Definition 
//----------------------------------------------------------------------------
MODELNAME = " Mixed-Flow Turbofan Cycle "; 
AUTHOR = "R. Denney & J. Tai"; 

Element FlightConditions Ambient { 
   alt = 0; 
   MN = 0.00; 
   W = 500; 
} 

Element InstalledInlet Inlet { 

   Table Tb_localMN(real MNfree) { 
     MNfree =  { 0.00, 0.10, 0.20, 0.32, 0.45, 0.60, 0.80, 1.00, 1.20, 1.40, 
                 1.60, 1.80, 2.00 } 
     MNlocal = { 0.00, 0.10, 0.20, 0.32, 0.45, 0.60, 0.80, 1.00, 1.20, 1.40, 
                 1.60, 1.80, 2.00 } 
   } 

   Fl_O.MN = 0.52;
   
   Subelement PipsiInletSub S_install { 
     Acapture = 7403.0;  
     #include <SFTF.Inlet.maps>; 
     void preexecute() {
     if (switchDes == "DESIGN") {
       // Acapture = 144.0*Ambient.W/Inlet.Fl_I.rhos/Inlet.Fl_I.Vflow/0.97;  //can't use this unless we size at TOC
       }
     }
   }
} 

Element Duct IGVDuct { 
   Fl_O.MN = 0.40; 
   dPqPbase = 0.010; 
} 

Element Compressor Fan { 
   #include <D60fan.ncp>

   void preexecute() { 
      d_etaPoly_FanTech = TechnologyFan_poly(TechnoLevel);
      Fan_etaPolyDesign = (Fan_etaPolyBase + d_etaPoly_FanTech) * k_etaFan;
   } 

   Fl_O.MN = 0.40;
   S_map.effDes = 0.9; 
   S_map.PRdes = 3.0;
   S_map.RlineMap = 2.2697;  
   S_map.NcDes = 1.0;   
} 

Element BasicMotor Motor{
	ind_Torque.autoSetup = TRUE;
}

Element Inverter Inverter{
	ind_Voltage.autoSetup = TRUE;
	InputVoltage = 10000.0;
    Subelement BasicInverterEfficiency S_Efficiency{}	
}

Element PowerCable MotorCable{
	Resistance = 0.001;
}

Element Bus Bus{
   DataInputPort Motor;
   DataOutputPort Battery;
   Dependent Dependent1;
   //PowerSourceSplit = {.25, .7};
}

Element Battery Batt {
	Capacity = 6.8;
	ExpZoneAmp = 0.144;
	ExpZoneTimeConst = 2.3077;
	PolarizationVoltage = 0.01875;
	NoLoadVoltage = 1.2848;
	Resistance = 0.0046;
	#include <Current_load.txt>
	StackDesignVoltage = 10000.0;
	timeStep = 1;
	dischargeInterval = 0.05;
	StateOfCharge = 100;
	//Batt.switchDes = DESIGN;
	DesPower = 4000000*2; //4*1491399.0; //W to ~2000hp
	FlightTime = 120; 
	CapDisLimit = 0.1; // 10% reserves
	TimeDesPower = 0.0;	
	
	Subelement BatteryWeight S_weight {
		SpecEnergy = 750;
		PowerDensity = 150;
		PowerBattNom = 7.8;
		VoltageNominal = 1.2;
	}
	Current = 0.15;
}

Element PowerCable SupplyCable{
	Resistance = 0.001;
}

Element DCTransformer DCTrans{
     dep_Power.autoSetup = TRUE;
     Subelement BasicDCTransformerEfficiency S_Efficiency{}
}


Element Splitter Splitter { 
   BPR = 1.5; 
   Fl_01.MN = 0.45; // swan neck duct inlet Mach number
   Fl_02.MN = 0.40;  // bypass duct inlet Mach number
} 

Element Compressor LPC { 
   #include <D60fan.ncp>

   Fl_O.MN = 0.35;
   S_map.effDes = 0.92; 
   S_map.PRdes = 1.45;
   S_map.RlineMap = 2.0;  
   S_map.NcDes = 1.0;   
   void postexecute(){
	   if(LPC.SMW < 10){
		   LPCOPBleed.LPCStabBld.stateDemand = "OPEN";
	   }
	   else{
		   LPCOPBleed.LPCStabBld.stateDemand = "CLOSE";
	   }
   }
} 

Element Bleed LPCOPBleed { 
   Fl_O.MN = 0.35; // OGV inlet Mach number  
   WrefName = "LPC.Fl_I.W";
   	DSV LPCStabBld {
		allowedValues = {"OPEN","CLOSE"}
		autoSetup = TRUE;
		controlBounce = TRUE;
		stateInitial = "CLOSE";
	}
	
	void preexecute(){
		if(LPCStabBld.state == "OPEN"){
			OpBleed.fracW = 0.05;
		}
		else if(LPCStabBld.state == "CLOSE"){
			OpBleed.fracW = 0.01;
		}
	}
	BleedOutPort OpBleed {
		fracW  = 0.00;
   }
} 

Element Duct SwanNeckDuct { 
   Fl_O.MN = 0.40; 
   dPqPbase = 0.010; 
} 

/*Element Compressor LPC { 
   #include <D60fan.ncp>


   Fl_O.MN = 0.40;
   S_map.effDes = 0.93; 
   S_map.PRdes = 1.45;
   S_map.RlineMap = 2.2697;  
   S_map.NcDes = 1.0;   
} */

Element Compressor HPC { 
   #include <D60hpc.ncp>

   void postexecute() {                                                        // Note postexecute not pre- RKD 12-10-07
	HPC_SizeWc = HPC.Fl_I.W*sqrt(HPC.Fl_O.Tt/518.67)/(HPC.Fl_O.Pt/14.696);
      d_etaPoly_HPCsize = CompressorSizeEffect(HPC_SizeWc, HPC.PR);
      d_etaPoly_HPCtech = TechnologyHPC_poly(TechnoLevel);
      HPC_etaPolyDesign = (HPC_etaPolyBase + d_etaPoly_HPCsize + d_etaPoly_HPCtech) *k_etaHPC;
   } 

   Fl_O.MN = 0.4; // OGV inlet Mach number

   S_map.effDes = 0.85; 
   S_map.NcDes = 1.0; 
   S_map.PRdes = 10.0; 
   S_map.RlineMap = 2.0782;
   
   InterStageBleedOutPort  ChargeBldOut3 { 
     fracBldWork = 0.5; 
     fracBldW = 0.04; // to be determined by solver
   }

   InterStageBleedOutPort  CustomerBld { 
     fracBldWork = 0.5; 
     fracBldW = 0.0000; 
   }
} 

Element Bleed CDPBld { 
   Fl_O.MN = 0.35; // OGV inlet Mach number  
   WrefName = "HPC.Fl_I.W";

   BleedOutPort  NonchargeBldOut { 
     fracW = 0.07; // to be determined by solver
   }

   BleedOutPort  ChargeBldOut1 { 
     fracW = 0.07; // to be determined by solver
   }

   BleedOutPort  ChargeBldOut2 { 
     fracW = 0.07; // to be determined by solver
   }
	
	BleedOutPort CustomerExitBld {
		fracW  = 0.00;
   }
} 

Element Duct1 OGVduct { 
   Fl_O.MN = 0.20;  // burner inlet Mach number
   Subelement dPqPMach S_dP { 
     dPqPMNdes = 0.03;        // to be determined by solver
     expMN = 2.0; 
   } 
} 

Element FuelStart Fuel { 
   Tref = 518.67;
   Tfuel = 518.67;
   Carbon = 1;	//Needed for JANAF
   Hydrogen = 0.16786;	//Needed for JANAF
   LHV = 18400.0;
} 

Element Burner1 Burner { 
   TtCombOut = 2800; 

   FAR = 0.035; 
   effBase = 0.997;// + TechnologyBurner(TechnoLevel); 
   dPqPBase = 0.035; // set to match dP/q at design point
   Fl_O.MN = 0.10; // required to get a Ps
   
   switchBurn = "FAR"; 

   Subelement NeppEI Emissions { 
     switchCalcType = "UTEP";
     altName = "Ambient.alt"; 
   } 

   void postexecute() { 
     Emissions.execute(); 
   } 
} 

Element Bleed FanBld { 
   Fl_O.MN = 0.40;  // bypass duct inlet Mach number

   WrefName = "HPC.Fl_I.W";
   BleedOutPort FanBldOut; 
   FanBldOut.fracW = 0.00001;   // was 0.001 RKD 11-13-07

   BleedOutPort FanBldOut2;
   
   BleedInPort LPCin;
   BleedInPort HPCin;
   
} 

Element HeatExchanger HX {
	switchQcalc = "EFFECT";
	effect = 0.75; 
}

Element Bleed HX_Split {
	BleedOutPort Out1 {
		fracW = 0.0;
	}
}

Element Bleed HPTvane {
 Fl_O.MN = 0.60;
 BleedInPort In1{}
}

Element Turbine HPT { 
   #include <D60hpt.ncp>
   
   FlowStation FS41; 
   real PREF_DES;
   real TREF_DES;

   void preexecute() {
     FS41.copyFlow("Fl_I"); 

     if (switchDes == DESIGN){
 	PREF_DES = FS41.Pt;
 	TREF_DES = FS41.Tt;
     }
	
//     if (switchDes == OFFDESIGN){
// 	HPT.S_map.S_Re.PtRef = PREF_DES;
// 	HPT.S_map.S_Re.TtRef = TREF_DES;
//     }
	  
	HPT_epsilon = 0.739595/FS41.gamt/(2./(FS41.gamt+1.))**(FS41.gamt/(FS41.gamt-1.));
      HPT_Theta = FS41.Tt/518.67;
      HPT_ThetaCr = 2.*FS41.gamt*32.174049*778.1692626*FS41.Rt*FS41.Tt/(FS41.gamt+1.)/1038718.086;
      HPT_SizeWc = FS41.W*sqrt(HPT_ThetaCr)*HPT_epsilon/(FS41.Pt/14.696);
	  
	  //Adjust size effects based on number of stages (Function of PR) CP 3-24-08
	  if(HPT.PR > 4.4){
		d_etaAdia_HPTsize = HPTurbineSizeEffect(HPT_SizeWc,2);
		}
	  if(HPT.PR <= 4.4){
		d_etaAdia_HPTsize = HPTurbineSizeEffect(HPT_SizeWc,1);
		}
     
      d_etaAdia_HPTtech = TechnologyHPT_adia(TechnoLevel);
			
      HPT_etaAdiaDesign = (HPT_etaAdiaBase + d_etaAdia_HPTsize + d_etaAdia_HPTtech) *k_etaHPT;
   } 

   Fl_O.MN = 0.40;   

   S_map.parmMap = 4.45;   
   S_map.effDes = 0.85;  
   S_map.parmNcDes = 100; 
   S_map.parmGeomMap = 1.0;

   InterStageBleedInPort  ChargeableBld { 
     Pfract = 0.0; 
   } 

//   void postexecute() { 
//     FS41.copyFlow("Fl_I"); 
//   } 
} 


Element Duct ITTduct {  // Duct used to connect the two turbines for WATE - RKD 4-22-08
   Fl_O.MN = 0.4;   // Same as HPT
   dPqPbase = 0.0;
} 


Element Turbine LPT { 
   #include <D60lpt.ncp>
   
   FlowStation FS49; 
   real PREF_DES;
   real TREF_DES;
   
   void preexecute() { 
     FS49.copyFlow("Fl_I"); 
    
     if (switchDes == DESIGN){
 	PREF_DES = FS49.Pt;
 	TREF_DES = FS49.Tt;
     }
	
//     if (switchDes == OFFDESIGN){
// 	LPT.S_map.S_Re.PtRef = PREF_DES;
// 	LPT.S_map.S_Re.TtRef = TREF_DES;
//    }
      LPT_epsilon = 0.739595/FS49.gamt/(2./(FS49.gamt+1.))**(FS49.gamt/(FS49.gamt-1.));
      LPT_Theta = FS49.Tt/518.67;
      LPT_ThetaCr = 2.*FS49.gamt*32.174049*778.1692626*FS49.Rt*FS49.Tt/(FS49.gamt+1.)/1038718.086;
      LPT_SizeWc = FS49.W*sqrt(LPT_ThetaCr)*LPT_epsilon/(FS49.Pt/14.696);
	d_etaAdia_LPTsize =  LPTurbineSizeEffect(LPT_SizeWc);
      d_etaAdia_LPTtech = TechnologyLPT_adia(TechnoLevel);
      LPT_etaAdiaDesign = (LPT_etaAdiaBase + d_etaAdia_LPTsize + d_etaAdia_LPTtech) * k_etaLPT;
   } 

   Fl_O.MN = 0.40;   // TEGV inlet Mach number

   S_map.parmMap = 2.26; 
   S_map.effDes = 0.9;
   S_map.parmNcDes = 100.; 
   S_map.parmGeomMap = 1.0;

   InterStageBleedInPort  ChargeableBld1 { 
     Pfract = 0.0; 
   } 

   InterStageBleedInPort  ChargeableBld2 { 
     Pfract = 0.0; 
   } 

   InterStageBleedInPort  ChargeableBld3 { 
     Pfract = 0.0; 
   } 

   InterStageBleedInPort  ChargeableBld4 { 
     Pfract = 0.0; 
   }
   
} 

Element Duct TEGVduct { 
   Fl_O.MN = 0.25;   // per Termap model
   dPqPbase = 0.010;
} 

Element Duct BPduct { 
   Fl_O.MN = 0.40; 
   //dPqPbase = 0.050;
   dPqPbase = 0.00; //set to zero to try to match hFan more closely
} 


Element Nozzle BypassNozzle { 
   real Cmix_exp = 1.0; 
   switchType = "CON_DIV";
//   switchType = "CONIC";
   switchCoef = "CFG";
//   Cv = 0.9999;
//   CdTh = 0.995;
   Cang = 1.0;
	Cfg = 0.99;
    

   PsExhName = "Ambient.Ps";
   //PsExh = 4.0;
}

Element Nozzle CoreNozzle { 
   real Cmix_exp = 1.0; 
   switchType = "CON_DIV";
//   switchType = "CONIC";
   switchCoef = "CFG";
//   Cv = 0.9999;
//   CdTh = 0.995;
   Cang = 1.0;
	Cfg = 0.99;
    

   PsExhName = "Ambient.Ps";
   //PsExh = 4.0;
}

Element FlowEnd BNozz_End { 
} 

Element FlowEnd CNozz_End { 
} 

//OBsink 1 no longer needed since compressor CDP bleed removed for customer (assumed all-elec) and rerouted to fan for operability
//Element FlowEnd OBsink1 { }  // flow ends for customer bleed
Element FlowEnd OBsink2 { }  // flow ends for CCA bleed
Element FlowEnd OBsink3 { }  // flow ends for customer bleed
Element FlowEnd OBsink4 { }  //flow ends for Inlet Bleed
Element FlowEnd OBsink5 { }  //flow ends for Inlet Bleed

Element Shaft1 HP_SHAFT { 
   ShaftInputPort HPC, HPT; 

   HPX = 256.0;    // was 75.0 R. Denney 10-26-07
   Nmech = 15000.0; 
} 

Element Shaft1 LP_SHAFT { 
   ShaftInputPort FAN, LPC, LPT, MOTOR; 
   HPX = 150.0;
   Nmech = 4600.0;   // was 90.0 R. Denney 6-21-05
} 

Element EngPerf Eng { 

   real FnFullPower, ThrustTarget, EPR, PC, EPC;  //Added EPC per GE definition
   real EPRtarget; real pcn2max;
   real FnetInstalled, TSFCInstalled, Fnet_local, FgInstalled, FnWa;
   real Q, Fdrag;
   real beta, A9QA10 = 1.0, L = 100.0;
   real r10, A10; 
   real fanPwrMax = 0.0; //Maximum fan power, used in EPC calculations in setuppartpower()
   #include <nozzle.cdmap>; 
   
   void postexecute() { 
   
     Fn = Fg - Inlet.Fram;   //EngPerf doesn't recognize InstalledInlet
     TSFC = Wfuel*3600/Fn;   // for the same reason as above
     EPR = LPT.Fl_O.Pt / Fan.Fl_I.Pt ;          // changed to Pt5 from Pt7 R. Denney 6-21-05
     OPR = HPC.Fl_O.Pt / Fan.Fl_I.Pt ;          // OPR is Pt3 / Pt2 R. Denney 6-21-05

     r10 = (Fan_Diameter + 10.0)/2.0;
     A10 = PI * r10**2;

     Q = (144.)*(0.5)*(Ambient.Fl_O.gams)*(Ambient.Fl_O.Ps)*Ambient.MN**2; 
     //A9QA10 = Nozzle.Fl_O.Aphy / A10 ; 
     //beta = (180./PI) * atan( ( r10 - (Nozzle.Fl_O.Aphy / PI)**0.5 ) / L ); 
     //Fdrag = 0.25*TB_CDAB( Ambient.MN, Nozzle.PR ) * (Q/144.) * A10 ;   // scale factor of 0.56 applied per Boeing
     Fdrag = 0;
     Fnet_local = Fg - Inlet.Fram_local ; 
     FgInstalled = Fg - 0*Inlet.Dinstall - Fdrag ; 
     FnetInstalled = Fnet_local - 0*Inlet.Dinstall - Fdrag ; 
     TSFCInstalled = WfuelHour / FnetInstalled ; 
     FnWa = FnetInstalled / Inlet.Fl_I.W;	 
	 
       EPRtarget = (((2.4197E-05)*Fan.NcqNcDesPct - 4.1450E-03)*Fan.NcqNcDesPct + 2.1744E-01)*Fan.NcqNcDesPct - 1.8083E+00;
          if (Fan.NcqNcDesPct < 72.88) { EPRtarget = 1.389; }
       pcn2max = 100.0;
   } 
} 


//----------------------------------------------------------------------------
//       linkPorts
//----------------------------------------------------------------------------

linkPorts( "Ambient.Fl_O"       , "Inlet.Fl_I"          , "FS0"   ); 
linkPorts( "Inlet.Fl_O"         , "IGVDuct.Fl_I"        , "FS1"   ); 
linkPorts( "IGVDuct.Fl_O"       , "Fan.Fl_I"            , "FS2"   ); 
linkPorts( "Fan.Fl_O"           , "Splitter.Fl_I"       , "FS21"  ); 
linkPorts( "Splitter.Fl_01"     , "LPC.Fl_I"			, "FS23"  );
linkPorts( "LPC.Fl_O"			, "LPCOPBleed.Fl_I"     , "FS23a" );
linkPorts( "LPCOPBleed.Fl_O"    , "SwanNeckDuct.Fl_I"   , "FS24"  ); 
//linkPorts( "SwanNeckDuct.Fl_O"  , "LPC.Fl_I"            , "FS24"  );
//linkPorts( "LPC.Fl_O"           , "HPC.Fl_I"            , "FS25"  ); 
linkPorts( "SwanNeckDuct.Fl_O"           , "HPC.Fl_I"            , "FS25"  ); 
linkPorts( "HPC.Fl_O"           , "CDPBld.Fl_I"         , "FS3"   ); 
linkPorts( "CDPBld.Fl_O"        , "OGVduct.Fl_I"        , "FS31"  ); 
linkPorts( "OGVduct.Fl_O"       , "Burner.Fl_I"         , "FS32"  ); 
linkPorts( "Fuel.Fu_O"          , "Burner.Fu_I"         , "FS36"  ); 
linkPorts( "Burner.Fl_O"        , "HPTvane.Fl_I"        , "FS4"   ); 
linkPorts( "HPTvane.Fl_O"       , "HPT.Fl_I"            , "FS41a" ); 
linkPorts( "HPT.Fl_O"			, "ITTduct.Fl_I"		, "FS45"  );
linkPorts( "ITTduct.Fl_O"       , "LPT.Fl_I"            , "FS48"  );
linkPorts( "LPT.Fl_O"           , "TEGVduct.Fl_I"       , "FS5"   ); 
linkPorts( "TEGVduct.Fl_O"      , "CoreNozzle.Fl_I"         , "FS56"  ); 

// BYPASS linkPorts
linkPorts( "Splitter.Fl_02"     , "FanBld.Fl_I"         , "FS13"  ); 
linkPorts( "FanBld.Fl_O"        , "BPduct.Fl_I"         , "FS14"  ); 
linkPorts( "BPduct.Fl_O"        , "BypassNozzle.Fl_I"         , "FS16"  ); 
linkPorts( "Inlet.BypassOut"    , "OBsink4.Fl_I"        , "FS17"  );

// Mixed stream
//linkPorts( "Mixer.Fl_O"         , "Tailpipe.Fl_I"       , "FS6"   ); 
//linkPorts( "Tailpipe.Fl_O"      , "Nozzle.Fl_I"         , "FS7"   ); 
linkPorts( "BypassNozzle.Fl_O"        , "CNozz_End.Fl_I"       , "FS19"   ); 
linkPorts( "CoreNozzle.Fl_O"        , "BNozz_End.Fl_I"       , "FS9"   ); 

// BLEED linkPorts
linkPorts("Inlet.BleedOut"         , "OBsink5.Fl_I"         , "IBO" );
linkPorts("CDPBld.NonchargeBldOut" , "HPTvane.In1"          , "C_FS41" ); 
//linkPorts("CDPBld.ChargeBldOut1"   , "HPT.ChargeableBld"    , "C_FS42" ); //Now includes compressor cooling and goes through HX
linkPorts("CDPBld.ChargeBldOut2"   , "LPT.ChargeableBld1"   , "C_FS48" ); 
linkPorts("HPC.ChargeBldOut3"      , "LPT.ChargeableBld2"   , "C_FS49" ); 
linkPorts("FanBld.FanBldOut"       , "HX.Fl_I2"			    , "C_CCA_B"); 
linkPorts("HX.Fl_O2"		 	   , "OBsink2.Fl_I"			, "OB_CCA" );
linkPorts("CDPBld.ChargeBldOut1"	   , "HX.Fl_I1"				, "CCA_in" );
linkPorts("HX.Fl_O1"			   , "HX_Split.Fl_I"		, "HX Split");
linkPorts("HX_Split.Fl_O"		   , "HPT.ChargeableBld"	, "C_FS42");
linkPorts("HX_Split.Out1"           , "LPT.ChargeableBld3"   , "HPC_COOL");
linkPorts("HPC.CustomerBld"        , "FanBld.HPCin"         , "HPCOP"); 
linkPorts("CDPBld.CustomerExitBld" , "OBsink3.Fl_I"			, "OB_Cust2");
linkPorts("FanBld.FanBldOut2"      , "LPT.ChargeableBld4"   , "C_FS5" );
linkPorts("LPCOPBleed.OpBleed"	   , "FanBld.LPCin"         , "LPCOP" );

//Electrical Link Ports
linkPorts("Motor.ElectricOutput"   , "Inverter.MOTOR"       , "M-I");
linkPorts("Inverter.CABLE"         , "MotorCable.INPUT"     , "I-C");
linkPorts("MotorCable.OUTPUT"      , "Bus.Motor"            , "C-B");
linkPorts("Bus.Battery"          , "SupplyCable.INPUT"    , "B-C");
linkPorts("SupplyCable.OUTPUT"     , "DCTrans.OUTPUT"     , "C-DC");
linkPorts("Batt.OUTPUT"            ,"DCTrans.INPUT",        "DC-B");


// SHAFT linkPorts
linkPorts( "Fan.Sh_O"           , "LP_SHAFT.FAN"        , "FANwork" ); 
linkPorts( "LPC.Sh_O"           , "LP_SHAFT.LPC"        , "LPCwork" ); 
linkPorts( "LPT.Sh_O"           , "LP_SHAFT.LPT"        , "LPTwork" ); 
linkPorts( "HPT.Sh_O"           , "HP_SHAFT.HPT"        , "HPTwork" ); 
linkPorts( "HPC.Sh_O"           , "HP_SHAFT.HPC"        , "HPCwork" ); 
linkPorts( "Motor.Sh_O"         , "LP_SHAFT.MOTOR"      , "MOTORwork" );

//----------------------------------------------------------------------------
//  Solver Sequence
//----------------------------------------------------------------------------
//solverSequence = { "Ambient", "Inlet", "Fan", "Splitter", "Duct5", "Duct1", 
//           "HPC", "Duct2", "Bld3", "Fuel", "Burner", "HPT", "LPT", "Duct3", 
//           "Mixer","Duct4", "Nozzle", "Nozz_End", "OBsink1", "OBsink2", 
//           "OBsink3", "LP_SHAFT", "HP_SHAFT", "Eng" } 

