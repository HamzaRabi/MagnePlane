// ****************************************************************************
// * ASDL 
// * Title: Robinson R22 Power Sizing and Power Calculation
// * Author: Kyle Collins
// *
// ****************************************************************************
class Helicopter extends Element {
  // -------------------------INPUT PARAMETERS-------------------------
  //Weight Parameters
  real GW {
    units = "lbf";
	description = "Gross weight of helicopter";
	value = 1370.0; // As long as we are analyzing the R22, keep this at 1370 lbf. We can change if sizing a new vehicle
  }
  
  real W {
    units = "lbf";
	description = "Instantaneous weight of helicopter";
	value = 1370.0; // This can change based on the fuel burn or whatever.
  }
  
  // Mission Parameters
  real V_kts {
    units = "knot";
	description = "Forward speed of helicopter in knots";
	value = 0.0; // This specifies the forward speed in knots.
  }
  
  real V {
    units = "ft/sec";
	description = "Forward speed of helicopter in fps";
	value = V_kts*1.68780986;
  }
  
  real Vc {
    units = "ft/sec";
	description = "Climb rate of helicopter in fps";
	value = 0; // This specifies the climb speed but remember it is in ft/sec. Typical climb speeds are 10-20 ft/sec.
  }
  // Need density and speed of sound below to come from some other function
  // Hard coding these variables now for testing
  real rho {
    units = "slug/ft3";
	description = "Density of air at flight condition";
	value = 0.0024;
  }
  
  real a {
    units = "ft/sec";
	description = "Speed of sound at flight condition";
	value = 1118.3;
  }
  
  // Scaling Parameters based on the R22
    // Weights
  real ewqgw {
    units = "none";
	description = "EW/GW ratio";
	value = 0.6058;
  }
  
    // Main Rotor
  real sigma_mr {
    units = "none";
	description = "Solidity of main rotor";
	value = 0.03;
  }
  
  real DL_mr {
    units = "lbf/ft2";
	description = "Disk loading of main rotor";
	value = 2.7556;
  }
  
  real Mtip_mr {
    units = "none";
	description = "Main rotor tip Mach number in hover at sea level";
	value = 0.6251;
  }
  
  real kappa_mr {
    units = "none";
	description = "Induced velocity correction factor for main rotor";
	value = 1.15;
  }
  
  real Cd0_mr {
    units = "none";
	description = "Drag coefficient of main rotor blade";
	value = 0.008;
  }
  
  real Kmu_mr {
    units = "none";
	description = "Main rotor forward flight power coefficient factor";
	value = 3;
  }
  
  real tl_mr {
    units = "none";
	description = "Main rotor effective blade radius for induced power calculation";
	value = 0.9;
  }
  
    //Tail Rotor
  real aratio_tr {
    units = "none";
	description = "Tail rotor area to main rotor area ratio";
	value = 0.0194;
  }
  
  real sigma_tr {
    units = "none";
	description = "Solidity of tail rotor";
	value = 0.12;
  }
   
  real Mtip_tr {
    units = "none";
	description = "Tail rotor tip Mach number in hover at sea level";
	value = 0.5571;
  }
  
  real kappa_tr {
    units = "none";
	description = "Induced velocity correction factor for tail rotor";
	value = 1.15;
  }
  
  real Cd0_tr {
    units = "none";
	description = "Drag coefficient of tail rotor blade";
	value = 0.008;
  }
  
  real Kmu_tr {
    units = "none";
	description = "Tail rotor forward flight power coefficient factor";
	value = 3;
  }
  
  real tl_tr {
    units = "none";
	description = "Tail rotor effective blade radius for induced power calculation";
	value = 0.9;
  }
    //Vertical Tail
  real aratio_vt {
    units = "none";
	description = "Vertical tail area to tail rotor area ratio";
	value = 0.3;
  }
  
  real CL_vt {
    units = "none";
	description = "Assume lift coefficient for fwd flight anti-torque";
	value = 0.12;
  }
  
    //fuselage
  real f {
    units = "ft2";
	description = "Equivalent flat plate drag area";
	// This is technically an input, but I am using a simple equation inside to calculate it based on GW, so I book-keep it in INPUT PARAMETERS
  }
  
    //Other Parameters
  real a_sl {
    units = "ft/sec";
	description = "Speed of sound at sea level";
	value = 1118.3; // For calculating tip speed of a sized configuration based on Mach tip.
  }
  real pi {
    units = "none";
	description = "The constant Pi";
	value = 3.14159265359;
  }
  // -------------------------OUTPUT PARAMETERS-------------------------
  real Ptot {
    units = "hp";
	description = "The total horsepower required by the helicopter in flight at speed V (and density set by altitude)";
  }
  
  string ambientRef {
	description = "Ambient Reference String";
	value = "Amb";
  }
  
  ShaftOutputPort Sh_O {
	description = "Shaft port connection";
  }
  
  void calculate() { 
     //Main Caclulate Function     
	 
	 //Set Ambient Conditions
	 rho = ambientRef->Fl_O.rhos "lbm/ft3";
	 
	 V = V_kts "knot";
	 // These calculated parameters will match the R-22 so long as GW=1370 lbf.
	 real Amr = GW/DL_mr; // area of main rotor disk ft^2
     real Rmr = (Amr/pi)**0.5; // radius of main rotor blade ft
     real Atr = aratio_tr*Amr; // area of tail rotor disk ft^2
     real Rtr = (Atr/pi)**0.5; // radius of tail rotor blade ft
     real Vtip_mr=Mtip_mr*a_sl; // main rotor tip speed ft/sec
     real Vtip_tr=Mtip_tr*a_sl; // tail rotor tip speed ft/sec
	 // cout << "Amr = " << Amr << endl;  //This is how you can print stuff
	
	
	 // --------------------- Calulate Power Required ---------------------
     // Calculate advance ratios
     real mu_mr=V/Vtip_mr; 
	 real mu_tr=V/Vtip_tr; // main and tail rotor advance ratios

     // Calculate parasite drag
	 f = GW/(7.6181*GW**0.4889);
     real drag=0.5*rho*V**2.*f; // parasite drag lbs

     // Calculate alpha from force balance
     real alpha=atan(drag/W); // alpha in radians
     
	 // Calculate total thrust of main rotor
     real T=(drag**2.+W**2.)**0.5; // main rotor thrust lbs
     real Ct_mr=T/(rho*Amr*Vtip_mr**2.); // main rotor Ct

     // Calculate main rotor inflow
     real inflow_mr=glauertinflow(mu_mr,alpha,Ct_mr); // main rotor inflow
	 
	 // Main rotor induced power
     real Cpi_mr=kappa_mr*Ct_mr*inflow_mr/tl_mr;
     real Pdim_mr=rho*Amr*Vtip_mr**3./550.; // diminsionalize Cp_mr to P_mr in HP
     real Pi_mr=Cpi_mr*Pdim_mr; // main rotor induced HP
	 
     // Main rotor profile power
     real Cpo_mr=sigma_mr*Cd0_mr/8.*(1.+Kmu_mr*mu_mr**2.);
     real Po_mr=Cpo_mr*Pdim_mr; // main rotor profile HP
	 
     // Main rotor parasite power
     real Cpp_mr=(0.5)*f*(mu_mr**3.)/Amr;
     real Pp_mr=Cpp_mr*Pdim_mr; // main rotor parasite HP

     // Main rotor climb power
     real Cpc_mr=Vc*W/(rho*Amr*Vtip_mr**3.);
     real Pc_mr=Cpc_mr*Pdim_mr; // main rotor climb HP

     // Total main rotor power
     real Cptot_mr=Cpi_mr + Cpo_mr + Cpp_mr + Cpc_mr;
     real Ptot_mr=Cptot_mr*Pdim_mr; // main rotor total HP
	 
     // Main rotor torque
     real Cq_mr=Cptot_mr;
     real Q_mr=Cq_mr*rho*Amr*Vtip_mr**2.*Rmr; // main rotor torque
	 //cout << "Q_mr = " << Q_mr << endl;

     // Anti-torque thrust
     real dtr=Rmr+Rtr+0.09; // tail rotor moment arm ft
     real Tat=Q_mr/dtr; // thrust needed for anti-torque
	 //cout << "Tat = " << Tat << endl;

     // Vertical tail thrust assumption
     real Svt=Atr*aratio_vt; // area of vertical tail assumed
     real Tvt=0.5*rho*V**2.*Svt*CL_vt;

     // Tail rotor thrust
     real Ttr=Tat-Tvt; // tail rotor thrust required lb
     real Ct_tr=Ttr/(rho*Atr*Vtip_tr**2.);	 

     // Calculate tail rotor inflow (assume alpha=0)
     real inflow_tr=glauertinflow(mu_tr,0,Ct_tr); // tail rotor inflow

     // Tail rotor induced power
     real Cpi_tr=kappa_tr*Ct_tr*inflow_tr/tl_tr;
     real Pdim_tr=rho*Atr*Vtip_tr**3./550.;  // dimensionalize Cp_tr to P_tr in HP
     real Pi_tr=Cpi_tr*Pdim_tr; // tail rotor induced HP

     // Tail rotor profile power
     real Cpo_tr=sigma_tr*Cd0_tr/8.*(1.+Kmu_tr*mu_tr**2.);
     real Po_tr=Cpo_tr*Pdim_tr; // tail rotor profile HP

     // Total tail rotor power
     real Cptot_tr=Cpi_tr + Cpo_tr;
     real Ptot_tr=Cptot_tr*Pdim_tr; // tail rotor total HP

     // Total power required
     Ptot=Ptot_mr + Ptot_tr; // total HP required // declared as real in global parameter declaration
	 
	 Sh_O.trq = Ptot / Sh_O.Nmech * C_HP_PER_RPMtoFT_LBF;  //ft-lbf
}  //closes calculate function
  
 
  real glauertinflow(real mu, real alpha, real Ct) {
		real inflowb = mu*tan(alpha)+Ct/(2.*(mu**2.+Ct/2.)**0.5);
		real converge = 100.0;
		
		while(converge  > 10.e-10) {
		real inflow=inflowb;
        inflowb=Ct/2./(mu**2.+(mu*tan(alpha)+inflow)**2.)**0.5;
        converge=abs(inflow-inflowb);
		}

		return inflow;	
  } //closes glauertinflow function
  
}  //This closes the class definition.  Everything, including other functions should be above this right curly.