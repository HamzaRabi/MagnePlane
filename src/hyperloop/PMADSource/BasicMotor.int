/* ******************************************************
*  File Name: BasicMotor.int                            *
*  Date: September 5, 2012                              *
*  Created by: David Trawick                            *
*  Last Edited: September 2, 2015                       *
*  By: Manish Pokhrel                                  *
*  For: Aerospace Systems Design Lab @ Georgia Tech     *
*******************************************************	*/

/* ******************************************************
*  Functions:                                           *
*	BasicMotor     class                                *
*******************************************************	*/

#include <InterpIncludes.ncp>

// ==============================================================================
// BasicMotor (class)
// NPSS model of an electric motor for modelling of the electrical systems
// of a hybrid electric propulsion system.  
// ------------------------------------------------------------------------------
class BasicMotor extends Element{
	// ==============================================================================
	// All values are nominal for 8000 hp motor calibrated to GE SUGAR data.
	// Values are then scaled to design power
	// Diameter ~ Torque ^ (1/3)
	// Volume ~ Diameter ^ 2
	// ------------------------------------------------------------------------------	

	   Table WindCd(real logRE) { 
		 logRE =  { 7.95962,	7.6006,	7.14497,	6.64115,	6.20638,	5.73721,	5.19908,	4.65412,	4.2059,	3.751,	3.47551,	3.28291,	3.15243,	3.06316,	3.00829 } 
		 Cd = { 1.22471,	1.33551,	1.52846,	1.91216,	2.26826,	2.78782,	3.4166,	4.12705,	4.91861,	5.9551,	6.82734,	7.72635,	8.5706,	9.16972,	9.6054 } 
	   }    
		
	  real Resistance { 
		value = 0; IOstatus = INPUT;//  units = Ohms;
		description = "Resistance of Stator";
		}
	  real Inductance {
		value = 0; IOstatus = INPUT;// units = Henrys;
		description = "Motor inductance";
		}
	  real Current {
		value = 2; IOstatus = OUTPUT;// units = Amps;
		description = "AC input Current magnitude";
		}
	  real Voltage {
		value = 500; IOstatus = OUTPUT;// units = Volts;
		description = "AC voltage across motor";
	  }
	  real Phase { 
		value = 0; IOstatus = OUTPUT;//  units = Radians;
		description = "Phase offset between Current & Voltage";//0 corresponds to 100% real power, positive=Current lagging voltage
		}
	  real Frequency { 
		value = 60; IOstatus = OUTPUT;//  units = Hertz;
		description = "Frequency of Electric Output Waveform";
	  }
	  real Torque {
		value = 1000; IOstatus = INPUT;// units = ft-lb
		description = "Output Torque";
	  }
	  real Speed {
		value = 50; IOstatus = INPUT;// units = rad/sec
		description = "Output shaft mechanical speed";
	  }
	  real Kv {
		value = .1; IOstatus = "input";// units = rad/sec/(volt)
		description = "Speed/Volt";
	  }
	  real Kt {
		value = 10; IOstatus = INPUT;// units = (ft-lb)/amp
		description = "Torque per amp";
	  }
	  real PolePairs {
		value = 6; IOstatus = INPUT;// units = none;
		description = "Number of pole pairs in the motor"; //f=w*PP/2*pi
		}
	  
	 real H_c {
		 value = 4.2; IOstatus = INPUT;
		 description = "Material Coercive Force (A/m)";
	 }
	 real B_p {
		 value = 2.5; IOstatus = INPUT;
		 description = "Peak Magentic Field (Tesla)";
	 }

	 real R0 {
		 value = 0.2; IOstatus = INPUT;
		 description = "Motor Phase Internal Resistance at 0 C (ohm)";
	 }
	 
	 real I0 {
		 value = 0.0; IOstatus = INPUT;
		 description = "Motor No-Load Current";
	 }
	 
	 real I0_Des {
		 value = 0.0; IOstatus = INPUT;
		 description = "Motor No-Load Current At Nbase";
	 }
	 
	 real imax {
		 value = 500.0; IOstatus = INPUT;
		 description = "Maximum motor phase Current (Amp)";
	 }
	 
	 real nphase {
		 value = 3; IOstatus = INPUT;
		 description = "Number of motor phases";
	 }
	 
	 real DesignPower {
		 value = 0.0; IOstatus = INPUT;
		 description = "Design value of motor (hp)";
	 }
	 
	 real Max_RPM {
		 value = 4600; IOstatus = INPUT;
		 description = "Maximum RPM of motor";
	 }
	 	  
	 real kappa {
		 value = 0.6; IOstatus = INPUT;
		 description = "Base speed / max speed";
	 }
	 
	 real Vmax {
		 value = 10000.0; IOstatus = INPUT;
		 description = "Maximum Phase Voltage";
	}
	 
	 real As {
		value = 95000.0; IOstatus = INPUT;
		description = "Electrical Loading";
	}

	real Dbase{
		value = 0.48; IOstatus = INPUT;
		description = "Base 8000 hp diameter for scaling purposes (m)";
	}

	real Lbase {
		value = 0.4; IOstatus = INPUT;
		description = "Base 8000 hp length for scaling purposes (m)";
	}
	 
	 real LDratio {
		value = 1.5; IOstatus = INPUT;
		description = "Length to diameter ratio of the motor";
	}
	
	 real CoreRadiusRatio {
		value = 0.4; IOstatus = INPUT;
		description = "Ratio of inner diameter of core to outer";
	}
	
	real k_Friction {
		value = 1.0; IOstatus = INPUT;
		description = "Friction coefficient calibration factor";
	}

	real Rd {
		value = 0.0; IOstatus = INPUT;
		description = "D-axis resistance per motor phase at very high-speed (short-circuit)";
	}	
	
	 real efficiency {
		 value = 0.0; IOstatus = OUTPUT;
		 description = "Motor efficiency";
	 }
	 
	real P_mech {
		value = 0.0; IOstatus = OUTPUT;
		description = "Mechanical Output Power";
	}

	real P_copper{
		value = 0.0; IOstatus = OUTPUT;
		description = "Copper Losses";
	}

	real P_iron{
		value = 0.0; IOstatus = OUTPUT;
		description = "Iron Losses";
	}

	real P_windage{
		value = 0.0; IOstatus = OUTPUT;
		description = "Windage Losses";
	}
		
	real Mass {
		value = 0.0; IOstatus = OUTPUT;
		description = "Mass of the motor";
	}
	
	DataOutputPort ElectricOutput;

	ShaftOutputPort Sh_O {
		description = "Shaft port connection";
	}

	Independent ind_Torque {
		varName = "Torque";
		autoSetup = TRUE;
	}

	string switchType {
		value = "BLDC";
		description = "Determines whether the element uses SRM or BLDC curves";
		IOstatus = INPUT;
	}
	
	string switchGenerator {
		value = "MOTOR";
		description = "Determines whether the element is generator or motor";
		IOstatus = INPUT;
	}
	
	real Rcalc, P_input; //For iterating in the solver on internal resistance and efficiency
	
	// OPTION VARIABLES
	Option switchDes {
		allowedValues = {DESIGN, OFFDESIGN};
		description = "Design switch";
		IOstatus = INPUT;
		rewritableValues = FALSE;
	}
	
	void variableChanged(string name, any oldVal) {
		if(switchDes == DESIGN) {
			Torque.IOstatus = OUTPUT;
		} else {
			Torque.IOstatus = INPUT;
		}
	} // end void variableChanged(string name, any oldVal)
	
	void calculate() {
				
		Kt=.73756214837/Kv;
		Speed = Sh_O.Nmech;
		Frequency = Speed*PolePairs/(2*PI);
		Current = Torque*Kt;
		real resistorVoltage = Current*Resistance;
		real inductorImpedance = Frequency*Inductance;//*j (j=sqrt(-1))
		real inductorVoltage = Current*inductorImpedance;//*j
		real speedVoltage = Kv*Speed;
		real realVoltage = speedVoltage + resistorVoltage;
		Voltage = sqrt(inductorVoltage**2+realVoltage**2);//magnitude of total voltage
		
		Phase = atan2(inductorVoltage,realVoltage);
		
		//Convert design power to W
		real Pmax = DesignPower * 746.0;  //Watts
		
		//Convert max RPM to rad/s
		real wmax = Max_RPM * 2*3.14159/60.0;
		real wmin = 0.086*wmax;
		real w = Speed * 2*3.14159/60.0;
		
		if(switchDes == DESIGN) {
			Torque = Pmax / wmax;
		}
		
		P_mech = w * Torque*1.355818;  //Watts
		
		//Create torque-speed curve for the motor
		real wbase = kappa*wmax; //base speed (rad/s)

		//Estimate Kt at wbase at max current
		real Tmax = Pmax / wbase; // Max phase torque in N-m
		Kv = (imax - I0_Des)/Tmax * (30./PI); 
		Kt = (30./PI) * (1./Kv);		
		Current = Torque*1.355818/Kt + I0;
		Voltage = Current*R0 + w / (Kv * PI/30.);		
				
		//Estimate Diameter for loss calculations -- Sizing is based off of type
		if(switchType == "SRM") {
			Dbase = 0.0713950*log((Pmax/746.0)) - 0.1572667;
		} else if (switchType == "BLDC") {
			real D2L = 293722. * ((Tmax)**(0.7592)); //From COTS BLDC data -- (mm)^3 
			Dbase = (D2L/LDratio)**(1./3.) / 1000.; // (meters)
			Mass = 0.0000070646*D2L**0.9386912061;  //kg
		}

		Lbase = LDratio * Dbase; // (meters)	

		//Calculate copper losses		
		//Set As as a function of power rating
		if(switchType == "SRM") {
			As = 8.8593834*(Pmax/746.0) + 24126.5371592;
		} else if (switchType == "BLDC") {
			As = 688.7 * imax; 
			// As = 581.14 * imax; 
		}

		//Calculate the total resistance
		real Tph = As*3.14159 * Dbase / imax / nphase / 2.0; //Calculate number of coil turns required
		real rpert = 48.8387296964863*imax**(-1.00112597971171); //Calculate resistance per km per turn
		real lm = Dbase * 3.14159; //Calculate length of a single winding
		real R = lm * rpert / 1000.0; //Calculate total resistance per turn
		
		Rcalc = R * Tph * nphase;
		
		real Rtotal;
		
		if(w > wbase) {
			Rtotal = R * Tph + Rd*(1-wbase/w)**2;
		} else {
			Rtotal = R * Tph;
		}
		
		//Calculate the Loss
		real P_copper_phase = Current * Current * Rtotal;
		P_copper = P_copper_phase*nphase;

		//Need frequency for iron losses
		Frequency = Speed*PolePairs/60;
		
		//Calculate iron losses
		real Kh = 0.0275;
		real Kc = 0.0000183;
		real Ke = 0.0000277;
		real Volume = PI * Lbase*(Dbase/2)**2.0*(1-CoreRadiusRatio**2);
		real Core_Weight = 7650.0 * Volume; //Calculate weight of core assuming laminated steel
		
		//Scale iron_volume on power (assuming speed range is close to baseline) 
		P_iron = (Kh * B_p * B_p * Frequency + Kc*(B_p*Frequency)**2.0 + Ke*(B_p*Frequency)**(1.5)) * Core_Weight ;

		//Calculate Windage Losses	
		//Calculate Friction and Windage Loss
		real Recalc = Dbase**2/4.0*w/2.075e-5*0.05;	
		real c_friction = 0.01;
		real Cd_calc;
		real diff = 1;
		
		while(abs(diff) > 0.001) {
			Cd_calc = 1.0 / (2.04+1.768*log(Recalc*c_friction**0.5))**2.;
			diff = (Cd_calc - c_friction)/Cd_calc;
		
			c_friction = Cd_calc;		
		}
		
		//Try other skin friction model
		real Re_r = Dbase**2/4.0*w/2.075e-5;
		real c_disk_friction = 0.08 /(0.05)**0.167 / Recalc**0.25;
		real P_disc_wind = 0.5 * c_friction * 1.2041 * w**3. * ((Dbase/2)**5.)*(1-CoreRadiusRatio**5.0);

		P_windage = k_Friction * (c_friction * PI * (w**3.0) * (Dbase/2)**4 * Lbase * 1.2041 + P_disc_wind);
		
		//Calculate output numbers
		P_input = P_mech + P_copper + P_iron + P_windage;
		if(switchGenerator == "MOTOR") {
			efficiency = P_mech / P_input;
		} else if(switchGenerator == "GENERATOR") {
			efficiency = P_input/P_mech;
		}
				
		Phase = 0; 

		Sh_O.trq = Torque;

		real electricOut[4];
		electricOut[0] = Voltage*sqrt(3./2.);  //Converts line to phase voltage for inverter
		electricOut[1] = Current/nphase;  //Converts to phase current from line
		electricOut[2] = Frequency;
		electricOut[3] = Phase;
		ElectricOutput.val = electricOut;
		
	}
}